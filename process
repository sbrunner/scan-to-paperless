#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import glob
import os
import re
import shutil
import subprocess  # nosec
import sys
import tempfile
import time
import traceback
from typing import List

import yaml
from skimage.measure import compare_ssim
import numpy as np
import cv2
from scipy.signal import find_peaks


CONVERT = ['gm', 'convert']


class Context:  # pylint: disable=too-few-public-methods
    def __init__(self, config, config_file_name=None, root_folder=None, image_name=None):
        self.config = config
        self.config_file_name = config_file_name
        self.root_folder = root_folder
        self.image_name = image_name
        self.image = None

    def process_count(self):
        try:
            return self.config['process_count']
        finally:
            self.config['process_count'] += 1


def add_intermediate_error(config, config_file_name, error, traceback_):
    if 'intermediate_error' not in config:
        config['intermediate_error'] = []

    old_intermediate_error = []
    old_intermediate_error.extend(config['intermediate_error'])
    try:
        config['intermediate_error'].append({
            'error': error,
            'traceback': traceback_,
        })
        with open(config_file_name + '_', 'w') as config_file:
            config_file.write(yaml.safe_dump(config, default_flow_style=False))
    except Exception as exception:
        print(exception)
        config['intermediate_error'] = old_intermediate_error
        config['intermediate_error'].append({
            'error': str(error),
            'traceback': traceback_,
        })
        with open(config_file_name + '_', 'w') as config_file:
            config_file.write(yaml.safe_dump(config, default_flow_style=False))
    os.rename(config_file_name + '_', config_file_name)


def call(cmd, **kwargs):
    if isinstance(cmd, list):
        cmd = [str(element) for element in cmd]
    print(' '.join(cmd) if isinstance(cmd, list) else cmd)
    sys.stdout.flush()
    subprocess.check_output(cmd, stderr=subprocess.PIPE, **kwargs)  # nosec


def output(cmd: List[str], **kwargs) -> str:
    if isinstance(cmd, list):
        cmd = [str(element) for element in cmd]
    print(' '.join(cmd) if isinstance(cmd, list) else cmd)
    sys.stdout.flush()
    return subprocess.check_output(cmd, stderr=subprocess.PIPE, **kwargs).decode()  # nosec


def image_diff(image1, image2):
    width = max(image1.shape[0], image2.shape[0])
    height = max(image1.shape[1], image2.shape[1])
    image1 = cv2.resize(image1, (width, height), interpolation=cv2.INTER_CUBIC)
    image2 = cv2.resize(image2, (width, height), interpolation=cv2.INTER_CUBIC)
    score, diff = compare_ssim(
        cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY),
        cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY),
        full=True
    )
    diff = (255 - diff * 255).astype("uint8")
    return score, diff


class Process:  # pylint: disable=too-few-public-methods
    def __init__(self, name, experimental=False, ignore_error=False):
        self.experimental = experimental
        self.name = name
        self.ignore_error = ignore_error

    def __call__(self, func):
        def wrapper(context, *args, **kwargs):
            if self.experimental and os.environ.get("EXPERIMENTAL", "FALSE") != "TRUE":
                return
            old_image = context.image.copy() if self.experimental else None
            if self.experimental or self.ignore_error:
                try:
                    new_image = func(context.image, *args, **kwargs)
                    if new_image is not None:
                        context.image = new_image
                except Exception as exception:
                    print(exception)
                    add_intermediate_error(
                        context.config, context.config_file_name,
                        exception, traceback.format_exc().split('\n')
                    )
            else:
                new_image = func(context.image, *args, **kwargs)
                if new_image is None:
                    raise Exception("No generated image...")
                context.image = new_image
            if self.experimental and context.image is not None:
                score, diff = image_diff(old_image, context.image)
                if diff is not None and score < 1.0:
                    dest_folder = os.path.join(context.root_folder, self.name)
                    if not os.path.exists(dest_folder):
                        os.makedirs(dest_folder)
                    dest_image = os.path.join(dest_folder, context.image_name)
                    cv2.imwrite(dest_image, diff)

            if not self.experimental:
                name = '{}-{}'.format(context.process_count(), self.name)
            else:
                name = self.name
            if self.experimental or os.environ.get("PROGRESS", "FALSE") == "TRUE":
                dest_folder = os.path.join(context.root_folder, name)
                if not os.path.exists(dest_folder):
                    os.makedirs(dest_folder)
                dest_image = os.path.join(dest_folder, context.image_name)
                cv2.imwrite(dest_image, context.image)

        return wrapper


def external(func):
    def wrapper(image, *args, **kwargs):
        source = tempfile.NamedTemporaryFile(suffix='.png')
        cv2.imwrite(source.name, image)
        destination = tempfile.NamedTemporaryFile(suffix='.png')
        func(source.name, destination.name, *args, **kwargs)
        return cv2.imread(destination.name)
    return wrapper


def crop(
        source, destination, marging_horizontal=25, maring_vertical=25, rm_top=25, rm_left=15, noise='7',
        blur='0x3', fuzz='25%'
):  # pylint: disable=too-many-arguments
    """
    Margin in px
    """
    o_w, o_h = [int(e) for e in output(CONVERT + [
        source, '-format', '%w %h', 'info:-'
    ]).strip().split(' ')]
    width, height, x, y = [int(e) for e in re.split('[x+]', output(CONVERT + [
        source, '-crop', '{}x{}+{}+{}'.format(o_w - rm_left, o_h - rm_top, rm_left, rm_top),
        '+repage', '-virtual-pixel', 'edge', '-noise', noise, '-blur', blur, '-fuzz',
        fuzz, '-format', '%@', 'info:-'
    ]).strip())]
    if height <= o_h and width <= o_w:
        call(CONVERT + [source, '-background', '#ffffff', '-crop', '{}x{}+{}+{}'.format(
            width + 2 * marging_horizontal, height + 2 * maring_vertical,
            x - marging_horizontal + rm_left, y - maring_vertical + rm_top
        ), '+repage', destination])
    else:
        shutil.copyfile(source, destination)


@Process('force-cleanup')
@external
def force_cleanup(source, destination, config):
    if config['args']['level']:
        call(CONVERT + ['-level', '15%,1,85%', source, destination])


@Process('precrop')
@external
def precrop(source, destination):
    marging_horizontal = 100
    maring_vertical = 100
    crop(
        source, destination,
        round(marging_horizontal / 10 / 2.51 * 300),
        round(maring_vertical / 10 / 2.51 * 300)
    )


@Process('deskew')
@external
def deskew(source, destination):
    call(['/opt/Deskew/Bin/deskew', '-b', 'FFFFFF', '-o', destination, source])


@Process('docrop')
@external
def docrop(source, destination):
    # Margin in mm
    marging_horizontal = 10
    maring_vertical = 7
    crop(
        source, destination,
        round(marging_horizontal / 10 / 2.51 * 300),
        round(maring_vertical / 10 / 2.51 * 300)
    )


@Process('sharpen')
@external
def sharpen(source, destination):
    call(CONVERT + ['-sharpen', '0x2', source, destination])


@Process('dither', True)
@external
def dither(source, destination):
    call(CONVERT + ['+dither', source, destination])


@Process('autorotate', False, True)
@external
def autorotate(source, destination):
    orientation = 0
    orientation = output([
        'tesseract', source, '-', '--psm', '0', '-l', 'osd'
    ])
#   orientation = output(['tesseract', source, '-', '--psm', '0', '-l', 'fra+eng'])
    orientation = [
        e for e in orientation.splitlines() if 'Orientation in degrees' in e
    ]
    orientation = '-' + orientation[0].split()[3]

    call(CONVERT + ['-rotate', orientation, source, destination])


def draw_line(image, vertical, position, value, name, type_):  # pylint: disable=too-many-arguments
    img_len = image.shape[0 if vertical else 1]
    color = (255, 0, 0) if vertical else (0, 255, 0)
    if vertical:
        cv2.rectangle(
            image, (int(position) - 1, img_len), (int(position) + 0, img_len - value), color, -1
        )
        cv2.putText(
            image, name, (int(position), img_len - value), cv2.FONT_HERSHEY_SIMPLEX, 2.0, color, 4
        )
    else:
        cv2.rectangle(
            image, (0, int(position) - 1), (value, int(position) + 0), color, -1
        )
        cv2.putText(
            image, name, (value, int(position)), cv2.FONT_HERSHEY_SIMPLEX, 2.0, color, 4
        )
    return {
        'name': name,
        'type': type_,
        'value': int(position),
        'vertical': vertical,
        'margin': 0,
    }


def find_lines(image, vertical):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    lines = cv2.HoughLinesP(
        image=edges, rho=0.02, theta=np.pi / 500, threshold=10, lines=np.array([]), minLineLength=100,
        maxLineGap=100
    )

    values = np.zeros(image.shape[1 if vertical else 0])
    for index in range(lines.shape[0]):
        line = lines[index][0]
        if line[0 if vertical else 1] == line[2 if vertical else 3]:
            values[line[0 if vertical else 1]] += \
                line[1 if vertical else 0] - line[3 if vertical else 2]
    correlated_values = np.correlate(values, [
        .2, .6, 1, .6, .2
    ])
    dist = 1
    peaks, properties = find_peaks(correlated_values, height=dist * 10, distance=dist)
    while len(peaks) > 3:
        dist *= 2
        peaks, properties = find_peaks(correlated_values, height=dist * 10, distance=dist)
    peaks += 2

    return peaks, properties


def zero_ranges(values):
    # Create an array that is 1 where a is 0, and pad each end with an extra 0.
    iszero = np.concatenate(([0], np.equal(values, 0).view(np.int8), [0]))
    absdiff = np.abs(np.diff(iszero))
    # Runs start and end where absdiff is 1.
    ranges = np.where(absdiff == 1)[0].reshape(-1, 2)
    return ranges


def find_limit_contour(image, vertical):
    contours = find_contours(image)
    image_size = image.shape[1 if vertical else 0]

    values = np.zeros(image_size)
    for x, _, width, height in contours:
        for value in range(x, min(x + width, image_size)):
            values[value] += height

    ranges = zero_ranges(values)

    result = []
    for ranges_ in ranges:
        if ranges_[0] != 0 and ranges_[1] != image_size:
            result.append(int(round(sum(ranges_) / 2)))

    return result


def fill_limits(image, vertical):
    peaks, properties = find_lines(image, vertical)
    contours = find_limit_contour(image, vertical)
    third_image_size = int(image.shape[0 if vertical else 1] / 3)
    limits = []
    prefix = 'V' if vertical else 'H'
    for index, peak in enumerate(peaks):
        value = int(round(properties['peak_heights'][index] / 3))
        limits.append(draw_line(
            image, vertical, peak, value, '{}L{}'.format(prefix, index), 'line detection'
        ))
    for index, contour in enumerate(contours):
        limits.append(draw_line(
            image, vertical, contour, third_image_size, '{}C{}'.format(prefix, index), 'contour detection'
        ))
    if not limits:
        half_image_size = image.shape[1 if vertical else 0] / 2
        limits.append(draw_line(
            image, vertical, half_image_size, third_image_size, '{}C'.format(prefix), 'image center'
        ))

    return limits


def find_contours(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Clean the image using otsu method with the inversed binarized image
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 17, 25)

    # Assign a rectangle kernel size
    kernel = np.ones((5, 5), 'uint8')
    par_img = cv2.dilate(thresh, kernel, iterations=5)

    contours, _ = cv2.findContours(par_img.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    result = []

    for cnt in contours:
        x, y, width, height = cv2.boundingRect(cnt)
        if width > 32 and height > 32:
            result.append((x + 8, y + 8, width - 16, height - 16))

    return result


@Process('scantailor', True)
@external
def scantailor(source, destination):
    call([
        'scantailor-cli', '--dpi=300', '--content-detection=normal',
        '--output-dpi=300', '--color-mode=color_grayscale',
        source, os.path.dirname(destination)
    ])


@Process('scantailor-1200', True)
@external
def scantailor_1200(source, destination):
    call([
        'scantailor-cli', '--dpi=300', '--content-detection=normal',
        '--output-dpi=300', '--color-mode=color_grayscale',
        source, os.path.dirname(destination)
    ])


@Process('scantailor-advanced', True)
@external
def scantailor_advanced(source, destination):
    call([
        'scantailor-advanced-cli', '--dpi=300', '--content-detection=normal',
        '--output-dpi=300', '--color-mode=color_grayscale',
        source, os.path.dirname(destination)
    ])


@Process('scantailor-advanced-1200', True)
@external
def scantailor_advanced_1200(source, destination):
    call([
        'scantailor-advanced-cli', '--dpi=300', '--content-detection=normal',
        '--output-dpi=300', '--color-mode=color_grayscale',
        source, os.path.dirname(destination)
    ])


@Process('scantailor-universal', True)
@external
def scantailor_universal(source, destination):
    call([
        'scantailor-universal-cli', '--dpi=300', '--content-detection=normal',
        '--output-dpi=300', '--color-mode=color_grayscale',
        source, os.path.dirname(destination)
    ])


@Process('scantailor-universal-1200', True)
@external
def scantailor_universal_1200(source, destination):
    call([
        'scantailor-universal-cli', '--dpi=300', '--content-detection=normal',
        '--output-dpi=300', '--color-mode=color_grayscale',
        source, os.path.dirname(destination)
    ])


@Process('tesseract', True)
@external
def tesseract(source, destination):
    call('tesseract -l fra+eng {} stdout pdf > {}'.format(source, destination), shell=True)  # nosec


def transform(config, config_file_name, root_folder):
    if 'intermediate_error' in config:
        del config['intermediate_error']

    images = list()

    if config['args']['assisted_split']:
        config['assisted_split'] = []

    for index, img in enumerate(config['images']):
        config['process_count'] = 0
        process_file = tempfile.NamedTemporaryFile(suffix='.png')
        image_path = process_file.name
        shutil.copyfile(os.path.join(root_folder, img), image_path)
        context = Context(config, config_file_name, root_folder, os.path.basename(img))
        context.image = cv2.imread(image_path)
        force_cleanup(context, config)
        precrop(context)
        deskew(context)
        docrop(context)
        sharpen(context)
        dither(context)
        autorotate(context)

        # is empty ?
        contours = find_contours(context.image)
        if not contours:
            print("Ignore image with no content: {}".format(img))
            continue

        scantailor(context)
        scantailor_1200(context)
        scantailor_advanced(context)
        scantailor_advanced_1200(context)
        scantailor_universal(context)
        scantailor_universal_1200(context)

        if config['args']['assisted_split']:
            assisted_split = {}
            name = os.path.join(root_folder, context.image_name)
            assisted_split['source'] = save_image(
                context.image, root_folder,
                '{}-assisted-split'.format(context.process_count()), context.image_name, True
            )

            config['assisted_split'].append(assisted_split)
            destinations = [len(config['images']) * 2 - index, index + 1]
            if index % 2 == 1:
                destinations.reverse()
            assisted_split['destinations'] = destinations

            limits = []
            limits.extend(fill_limits(context.image, True))
            limits.extend(fill_limits(context.image, False))
            assisted_split['limits'] = limits

            cv2.imwrite(name, context.image)
            assisted_split['image'] = context.image_name
            images.append(name)
        else:
            img2 = os.path.join(root_folder, context.image_name)
            cv2.imwrite(img2, context.image)
            images.append(img2)

    return images


def save(root_folder, img, folder, force=False):
    if force or os.environ.get("PROGRESS") == "TRUE":
        dest_folder = os.path.join(root_folder, folder)
        if not os.path.exists(dest_folder):
            os.makedirs(dest_folder)
        dest_file = os.path.join(dest_folder, os.path.basename(img))
        shutil.copyfile(img, dest_file)
        return dest_file
    return img


def save_image(image, root_folder, folder, name, force=False):
    if force or os.environ.get("PROGRESS") == "TRUE":
        dest_folder = os.path.join(root_folder, folder)
        if not os.path.exists(dest_folder):
            os.makedirs(dest_folder)
        dest_file = os.path.join(dest_folder, name)
        cv2.imwrite(dest_file, image)
        return dest_file
    return None


def split(config, root_folder, config_file_name):
    for assisted_split in config['assisted_split']:
        if assisted_split['limits']:
            if len(assisted_split['limits']) != len(assisted_split['destinations']) - 1:
                raise Exception("Wrong number of limits ({}) or destinations ({}) for img '{}'".format(
                    len(assisted_split['limits']),
                    len(assisted_split['destinations']),
                    assisted_split['source'],
                ))
            vertical = assisted_split['limits'][0]['vertical']
            for limit in assisted_split['limits']:
                if limit['vertical'] != vertical:
                    raise Exception("Mix of limit type for img '{}'".format(assisted_split['source']))

    for assisted_split in config['assisted_split']:
        image_path = os.path.join(root_folder, assisted_split['image'])
        if os.path.exists(image_path):
            os.unlink(image_path)

    append = {}
    transformed_images = []
    context = Context(config)
    for assisted_split in config['assisted_split']:
        img = assisted_split['source']
        width, height = [int(e) for e in output(CONVERT + [
            img, '-format', '%w %h', 'info:-'
        ]).strip().split(' ')]
        vertical = assisted_split['limits'][0]['vertical']
        last_pos = 0
        for number, destination in enumerate(assisted_split['destinations']):
            if number < len(assisted_split['limits']):
                limit = assisted_split['limits'][number]
                value = limit['value']
                margin = limit['margin']
            else:
                value = width if vertical else height
                margin = 0
            if destination == '-':
                last_pos = value + margin
            else:
                if number < len(assisted_split['limits']):
                    limit = assisted_split['limits'][number]
                    value = limit['value']
                    margin = limit['margin']
                else:
                    value = width if vertical else height
                    margin = 0
                process_file = tempfile.NamedTemporaryFile(suffix='.png')
                img2 = process_file.name
                if vertical:
                    call(CONVERT + [
                        '-crop', '{}x{}+{}+0'.format(value - margin - last_pos, height, last_pos),
                        '+repage', img, img2
                    ])
                else:
                    call(CONVERT + [
                        '-crop', '{}x{}+0+{}'.format(width, value - margin - last_pos, last_pos),
                        '+repage', img, img2
                    ])
                last_pos = value + margin

                if re.match(r'[0-9]+\.[0-9]+', str(destination)):
                    page, page_pos = [int(e) for e in destination.split('.')]
                else:
                    page = destination
                    page_pos = 0

                save(root_folder, img2, '{}-split'.format(context.process_count()))
                marging_horizontal = 10
                maring_vertical = 7
                img3_file = tempfile.NamedTemporaryFile(suffix='.png')
                img3 = img3_file.name
                crop(
                    img2,
                    img3,
                    round(marging_horizontal / 10 / 2.51 * 300),
                    round(maring_vertical / 10 / 2.51 * 300)
                )
                save(root_folder, img3, '{}-crop'.format(context.process_count()))
                if page not in append:
                    append[page] = []
                append[page].append({
                    'file': img3_file,
                    'pos': page_pos,
                    'vertical': vertical
                })

    for page in sorted(append.keys()):
        items = append[page]
        vertical = items[0]['vertical']
        for element in items:
            if element['vertical'] != vertical:
                raise Exception("Mix of limit type for page '{}'".format(page))

        process_file = tempfile.NamedTemporaryFile(suffix='.png')
        img = process_file.name
        call(CONVERT + [e['file'].name for e in sorted(items, key=lambda e: e['pos'])] + [
            '-background', '#ffffff', '-gravity', 'center', '+append' if vertical else '-append', img
        ])
        save(root_folder, img, '{}-split'.format(context.process_count()))
        img2 = os.path.join(root_folder, 'image-{}.png'.format(page))
        call(CONVERT + [img, img2])
        transformed_images.append(img2)

    config['splitted'] = True
    config['transformed_images'] = transformed_images
    with open(os.path.join(root_folder, 'REMOVE_TO_CONTINUE'), 'w'):
        pass
    with open(config_file_name + '_', 'w') as config_file:
        config_file.write(yaml.safe_dump(config, default_flow_style=False))
    os.rename(config_file_name + '_', config_file_name)


def finalise(config, root_folder):
    """
    Final step on document generation (convert in one pdf and copy with the right name in the cusume folder)
    """

    full_name = config['full_name']
    destination = config['destination']

    if os.path.exists(destination):
        return

    images = config['transformed_images']

    if config['args']['append_credit_card']:
        images2 = []
        for img in images:
            if os.path.exists(img):
                images2.append(img)

        call(CONVERT + images2 + [
            '-background', '#ffffff', '-gravity', 'center', '-append',
            os.path.join(root_folder, 'final.png')
        ])
        images = [os.path.join(root_folder, 'final.png')]

    pdf = []
    for img in images:
        if os.path.exists(img):
            name = os.path.splitext(os.path.basename(img))[0]
            call('tesseract -l fra+eng {} stdout pdf > {}'.format(
                img, os.path.join(root_folder, '{}-tesseract.pdf'.format(name))
            ), shell=True)  # nosec
            call(CONVERT + [img, '+repage', os.path.join(root_folder, '{}.pdf'.format(name))])
            pdf.append(os.path.join(root_folder, '{}.pdf'.format(name)))

    call(['pdftk'] + pdf + ['output', destination, 'compress'])
    call(['exiftool', '-overwrite_original_in_place', '-Title=' + full_name, destination])

    if os.environ.get("PROGRESS", "FALSE") != "TRUE":
        shutil.rmtree(root_folder)
    else:
        with open(os.path.join(root_folder, 'DONE'), 'w'):
            pass


def write_error(root_folder, message):
    if not os.path.exists(os.path.join(root_folder, 'error.yaml')):
        with open(os.path.join(root_folder, 'error.yaml'), 'w') as error_file:
            error_file.write(yaml.safe_dump({
                'error': message,
            }, default_flow_style=False))


def is_allready_proceed(config):
    if 'transformed_images' not in config:
        return False
    for img in config['transformed_images']:
        if not os.path.exists(img):
            return False
    return True


def is_source_present(config, root_folder):
    for img in config['images']:
        if not os.path.exists(os.path.join(root_folder, img)):
            return False
    return True


def main():
    """
    Main function
    """
    print('Welcome to scanned images document to paperless.')
    while True:
        for config_file_name in glob.glob('/source/*/config.yaml'):
            if not os.path.exists(config_file_name):
                continue

            root_folder = os.path.dirname(config_file_name)

            if os.path.exists(os.path.join(root_folder, 'error.yaml')):
                continue

            with open(config_file_name) as config_file:
                config = yaml.safe_load(config_file.read())
            if config is None:
                write_error(root_folder, 'Empty config')
                continue

            try:
                if is_allready_proceed(config):
                    if os.path.exists(os.path.join(root_folder, 'DONE')):
                        continue

                    if os.path.exists(os.path.join(root_folder, 'REMOVE_TO_CONTINUE')):
                        continue

                    if config['args']['assisted_split'] and not config.get('splitted', False):
                        print(config_file_name)
                        print("Split")
                        split(config, root_folder, config_file_name)
                    else:
                        print(config_file_name)
                        print("Finalise")
                        finalise(config, root_folder)
                else:
                    if not is_source_present(config, root_folder):
                        write_error(root_folder, 'Missing one of sources images')
                        continue

                    print(config_file_name)
                    print("Transform")

                    config['transformed_images'] = transform(config, config_file_name, root_folder)
                    with open(config_file_name + '_', 'w') as config_file:
                        config_file.write(yaml.safe_dump(config, default_flow_style=False))
                    os.rename(config_file_name + '_', config_file_name)

                    with open(os.path.join(root_folder, 'REMOVE_TO_CONTINUE'), 'w'):
                        pass

            except Exception as exception:
                print(exception)
                try:
                    with open(os.path.join(root_folder, 'error.yaml'), 'w') as error_file:
                        error_file.write(yaml.dump({
                            'error': exception,
                            'traceback': traceback.format_exc().split('\n'),
                        }, default_flow_style=False))
                except Exception as exception2:
                    print(exception2)
                    with open(os.path.join(root_folder, 'error.yaml'), 'w') as error_file:
                        error_file.write(yaml.safe_dump({
                            'error': str(exception2),
                            'traceback': traceback.format_exc().split('\n'),
                        }, default_flow_style=False))

        sys.stdout.flush()
        time.sleep(30)


if __name__ == "__main__":
    main()
